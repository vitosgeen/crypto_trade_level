<!-- index.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Level Trader Bot</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: #f0f2f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            text-align: left;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        input,
        select {
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        .delete-btn {
            background: #dc3545;
        }

        .delete-btn:hover {
            background: #a71d2a;
        }

        /* Gauge Styles */
        .gauge-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .gauge {
            position: relative;
            width: 200px;
            height: 100px;
            overflow: hidden;
        }

        .gauge-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: conic-gradient(from 270deg, #dc3545 0deg 90deg, #28a745 90deg 180deg, transparent 180deg);
            /* Mask bottom half */
            clip-path: polygon(0 0, 100% 0, 100% 50%, 0 50%);
        }

        .gauge-needle {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 4px;
            height: 90px;
            background: #333;
            transform-origin: bottom center;
            transform: rotate(-90deg);
            /* -90=Left, 90=Right */
            transition: transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 2;
            border-radius: 2px;
        }

        .gauge-center {
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 20px;
            height: 20px;
            background: #333;
            border-radius: 50%;
            transform: translateX(-50%);
            z-index: 3;
        }

        .gauge-labels {
            display: flex;
            justify-content: space-between;
            width: 200px;
            margin-top: 5px;
            font-weight: bold;
        }

        .gauge-value {
            margin-top: 5px;
            font-family: monospace;
            font-size: 1.1em;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Level Trader Bot</h1>

        <div class="card">
            <h2>Add Level</h2>
            <form hx-post="/levels" hx-target="#levels-table">
                <input type="text" name="exchange" placeholder="Exchange (bybit)" value="bybit" required>
                <input type="text" name="symbol" placeholder="Symbol (BTCUSDT)" required>
                <input type="number" step="0.000001" name="level_price" id="input-level-price" placeholder="Level Price"
                    required>
                <input type="number" step="0.001" name="base_size" placeholder="Base Size" required>
                <input type="number" name="leverage" placeholder="Leverage" value="10" required>
                <select name="margin_type">
                    <option value="isolated">Isolated</option>
                    <option value="cross">Cross</option>
                </select>
                <input type="number" name="cool_down_ms" placeholder="Cooldown (ms)" value="5000" required>
                <div style="margin-top: 10px; display: flex; align-items: flex-start; gap: 10px;">
                    <label style="margin-top: 5px;">Tiers (%):</label>
                    <div>
                        <input type="number" step="0.01" name="tier1" id="input-tier1" placeholder="Tier 1 (0.5)"
                            value="0.5" required style="width: 80px;">
                        <div id="tip-tier1" style="font-size: 0.8em; color: #666; margin-top: 2px;"></div>
                    </div>
                    <div>
                        <input type="number" step="0.01" name="tier2" id="input-tier2" placeholder="Tier 2 (0.3)"
                            value="0.3" required style="width: 80px;">
                        <div id="tip-tier2" style="font-size: 0.8em; color: #666; margin-top: 2px;"></div>
                    </div>
                    <div>
                        <input type="number" step="0.01" name="tier3" id="input-tier3" placeholder="Tier 3 (0.15)"
                            value="0.15" required style="width: 80px;">
                        <div id="tip-tier3" style="font-size: 0.8em; color: #666; margin-top: 2px;"></div>
                    </div>
                </div>
                <div class="mb-4">
                    <label class="flex items-center space-x-2">
                        <input type="checkbox" name="stop_loss_at_base" class="form-checkbox text-blue-500">
                        <span class="text-gray-300">Stop Loss at Base</span>
                    </label>
                </div>

                <div class="mb-4">
                    <label class="block text-gray-400 text-sm mb-2">Stop Loss Mode</label>
                    <select name="stop_loss_mode"
                        class="w-full bg-gray-700 text-white p-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none">
                        <option value="exchange">Exchange (Order)</option>
                        <option value="app">App (Programmatic)</option>
                    </select>
                </div>
                <button type="submit" style="margin-top: 10px;">Add Level</button>
            </form>
        </div>

        <div class="card">
            <span style="color: #000;">‚îÅ</span> Base Level |
            <span style="color: #666;">- - -</span> Tiers
        </div>
    </div>

    <div class="card">
        <h2>Market Speed & Depth</h2>
        <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 20px;">
            <!-- Gauge 1: Trade Speed -->
            <div class="gauge-container">
                <h3 style="text-align: center; margin-bottom: 10px;">Trade Volume (60s)</h3>
                <div class="gauge">
                    <div class="gauge-bg"></div>
                    <div class="gauge-needle" id="speed-needle"></div>
                    <div class="gauge-center"></div>
                </div>
                <div class="gauge-labels">
                    <span style="color: #dc3545;">Sell</span>
                    <span style="color: #28a745;">Buy</span>
                </div>
                <div class="gauge-value" id="speed-value">0 / 0</div>
            </div>

            <!-- Gauge 2: Order Book Depth -->
            <div class="gauge-container">
                <h3 style="text-align: center; margin-bottom: 10px;">Order Book Depth</h3>
                <div class="gauge">
                    <div class="gauge-bg"></div>
                    <div class="gauge-needle" id="depth-needle"></div>
                    <div class="gauge-center"></div>
                </div>
                <div class="gauge-labels">
                    <span style="color: #dc3545;">Ask</span>
                    <span style="color: #28a745;">Bid</span>
                </div>
                <div class="gauge-value" id="depth-value">0 / 0</div>
            </div>

            <!-- Gauge 3: Divergence -->
            <div class="gauge-container">
                <h3 style="text-align: center; margin-bottom: 10px;">Sentiment Divergence</h3>
                <div class="gauge">
                    <div class="gauge-bg"
                        style="background: conic-gradient(from 270deg, #ffc107 0deg 90deg, #007bff 90deg 180deg, transparent 180deg);">
                    </div>
                    <div class="gauge-needle" id="div-needle"></div>
                    <div class="gauge-center"></div>
                </div>
                <div class="gauge-labels">
                    <span style="color: #ffc107;">Bearish Div</span>
                    <span style="color: #007bff;">Bullish Div</span>
                </div>
                <div class="gauge-value" id="div-value">0.00</div>
            </div>
        </div>
    </div>

    <div class="card">
        <h2>Select Level</h2>
        <div style="display: flex; align-items: center; gap: 10px;">
            <label for="level-selector">Level:</label>
            <select id="level-selector" onchange="changeLevel()"
                style="padding: 8px; border-radius: 4px; border: 1px solid #ddd; min-width: 200px;">
                <option value="" selected disabled>Select a level...</option>
                {{range .Levels}}
                <option value="{{.ID}}">{{.Exchange}} - {{.Symbol}} - {{.LevelPrice}}</option>
                {{end}}
            </select>
        </div>
    </div>

    <div class="card" id="chart-card">
        <h2>Price Chart</h2>
        <div id="levelChart" style="width: 100%; height: 400px;"></div>
    </div>

    <div class="card">
        <h2>Active Levels</h2>
        <div id="levels-table" hx-get="/levels" hx-trigger="every 2s">
            {{ template "levels_table" .Levels }}
        </div>
    </div>

    <script>
        let chart = null;
        let candleSeries = null;
        let liquiditySeries = null; // New series for background lines
        let selectedLevelId = null;
        let currentPriceLines = [];

        function initChart() {
            console.log("Initializing Chart...");
            const chartContainer = document.getElementById('levelChart');
            if (!chartContainer) {
                console.error("Chart container not found!");
                return;
            }

            // Clear previous content
            chartContainer.innerHTML = '';

            if (typeof LightweightCharts === 'undefined') {
                console.error("LightweightCharts library not loaded!");
                return;
            }

            try {
                chart = LightweightCharts.createChart(chartContainer, {
                    width: chartContainer.clientWidth || 800, // Fallback width
                    height: 400,
                    layout: {
                        background: { type: 'solid', color: 'white' },
                        textColor: 'black',
                    },
                    grid: {
                        vertLines: { color: '#eee' },
                        horzLines: { color: '#eee' },
                    },
                    rightPriceScale: {
                        borderColor: '#d1d4dc',
                    },
                    timeScale: {
                        borderColor: '#d1d4dc',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });

                // 1. Create Liquidity Series FIRST (so it renders behind)
                // We use a LineSeries but make it invisible
                liquiditySeries = chart.addLineSeries({
                    color: 'transparent',
                    lineWidth: 0,
                    crosshairMarkerVisible: false,
                    lastValueVisible: false,
                    priceLineVisible: false,
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                });

                // 2. Create Candle Series SECOND (so it renders on top)
                candleSeries = chart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderVisible: false,
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                    priceFormat: {
                        type: 'price',
                        precision: 6,
                        minMove: 0.000001,
                    },
                });

                console.log("Chart initialized. Series:", candleSeries);

                // Handle resize
                window.addEventListener('resize', () => {
                    if (chart && chartContainer) {
                        chart.applyOptions({ width: chartContainer.clientWidth });
                    }
                });
            } catch (e) {
                console.error("Error initializing chart:", e);
                chart = null;
                candleSeries = null;
                liquiditySeries = null;
            }
        }

        function changeLevel() {
            const selector = document.getElementById('level-selector');
            selectedLevelId = selector.value;
            updateChart();
        }

        async function updateChart() {
            if (!chart) {
                initChart();
                if (!chart) {
                    console.warn("Chart init failed, skipping update");
                    return;
                }
            }

            if (!candleSeries || !liquiditySeries) {
                console.error("Series is null, re-initializing...");
                // Try to recover?
                initChart();
                if (!candleSeries) return;
            }

            // Get data from the levels table to find selected level details
            const table = document.querySelector('#levels-table table');
            if (!table) return;

            const rows = table.querySelectorAll('tbody tr');
            if (rows.length === 0) return;

            // Populate selector logic (same as before)
            const selector = document.getElementById('level-selector');
            if (!selector) {
                if (typeof updateChartRetryCount !== 'undefined' && updateChartRetryCount < 5) {
                    updateChartRetryCount++;
                    console.warn(`Level selector not found, retrying (${updateChartRetryCount}/5)...`);
                    setTimeout(updateChart, 500);
                } else {
                    console.error("Level selector not found after retries");
                }
                return;
            }
            if (typeof updateChartRetryCount !== 'undefined') updateChartRetryCount = 0;

            const currentOptions = Array.from(selector.options).map(o => o.value);
            const availableLevels = [];
            const activeIds = [];

            rows.forEach((row) => {
                const cells = row.querySelectorAll('td');
                const symbol = cells[1].textContent.trim();
                const levelPrice = parseFloat(cells[2].textContent);
                const id = `${symbol}-${levelPrice}`;
                activeIds.push(id);
                availableLevels.push({ id, text: `${symbol} @ ${levelPrice}` });

                if (!currentOptions.includes(id)) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.text = `${symbol} @ ${levelPrice}`;
                    selector.appendChild(option);
                }
            });

            // Cleanup options
            Array.from(selector.options).forEach(option => {
                if (option.value && !activeIds.includes(option.value)) {
                    selector.removeChild(option);
                }
            });

            // Default selection
            if ((!selectedLevelId || !activeIds.includes(selectedLevelId)) && availableLevels.length > 0) {
                selectedLevelId = availableLevels[0].id;
                selector.value = selectedLevelId;
            }

            // Find target row
            let targetRow = null;
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const symbol = cells[1].textContent.trim();
                const levelPrice = parseFloat(cells[2].textContent);
                const id = `${symbol}-${levelPrice}`;
                if (id === selectedLevelId) {
                    targetRow = row;
                }
            });

            if (!targetRow) return;

            const cells = targetRow.querySelectorAll('td');
            const symbol = cells[1].textContent.trim();
            const levelPrice = parseFloat(cells[2].textContent);

            // Fetch Candles
            try {
                const response = await fetch(`/api/candles?symbol=${symbol}&interval=1&limit=200`);
                const candles = await response.json();
                if (candles && candles.length > 0) {
                    // Ensure candles are sorted by time (ascending)
                    candles.sort((a, b) => a.time - b.time);

                    // Deduplicate candles by time
                    const uniqueCandles = [];
                    const seenTimes = new Set();
                    for (const c of candles) {
                        if (!seenTimes.has(c.time)) {
                            seenTimes.add(c.time);
                            uniqueCandles.push(c);
                        }
                    }

                    candleSeries.setData(uniqueCandles);

                    // Sync liquiditySeries with same data (using close price)
                    // This ensures it shares the same scale and range
                    const lineData = uniqueCandles.map(c => ({ time: c.time, value: c.close }));
                    liquiditySeries.setData(lineData);

                    // Only auto-scale if symbol changed or first load
                    if (window.lastChartSymbol !== symbol) {
                        chart.timeScale().fitContent();
                        chart.priceScale('right').applyOptions({
                            autoScale: true,
                        });
                        window.lastChartSymbol = symbol;
                    }
                }
            } catch (e) {
                console.error("Failed to fetch candles", e);
            }

            // Update Price Lines (Level and Tiers)
            // We will track active lines to avoid clearing/re-adding if not needed.
            // However, LightweightCharts doesn't support updating PriceLine properties easily.
            // But for Liquidity lines, we can diff the data.
            // For Level/Tiers, they change rarely (only if user edits).

            // Strategy:
            // 1. Level/Tiers: Clear and re-add ONLY if level details changed (price/tiers).
            // 2. Liquidity: Fetch, diff with current. If different, clear and re-add ONLY liquidity lines.

            // For simplicity in this MVP, let's separate the arrays.
            // currentLevelLines (Base + Tiers)
            // currentLiquidityLines (Order Book)

            // Parse Tiers from the nested table in cell 4
            const tierCell = cells[4];
            const nestedTable = tierCell.querySelector('table');
            let longTier1, longTier2, longTier3, shortTier1, shortTier2, shortTier3;

            if (nestedTable) {
                const nestedRows = nestedTable.querySelectorAll('tr');
                if (nestedRows.length >= 2) {
                    // Long Tiers (Row 0)
                    const longCells = nestedRows[0].querySelectorAll('td');
                    longTier1 = parseFloat(longCells[1].textContent);
                    longTier2 = parseFloat(longCells[2].textContent);
                    longTier3 = parseFloat(longCells[3].textContent);

                    // Short Tiers (Row 1)
                    const shortCells = nestedRows[1].querySelectorAll('td');
                    shortTier1 = parseFloat(shortCells[1].textContent);
                    shortTier2 = parseFloat(shortCells[2].textContent);
                    shortTier3 = parseFloat(shortCells[3].textContent);
                }
            }

            // Fallback if parsing fails (shouldn't happen if table structure is correct)
            if (!longTier1) {
                console.warn("Failed to parse tiers from table, using defaults");
                longTier1 = levelPrice * (1 + 0.005);
                longTier2 = levelPrice * (1 + 0.003);
                longTier3 = levelPrice * (1 + 0.0015);
                shortTier1 = levelPrice * (1 - 0.005);
                shortTier2 = levelPrice * (1 - 0.003);
                shortTier3 = levelPrice * (1 - 0.0015);
            }

            // Check if level details changed
            const levelDetails = {
                price: levelPrice,
                long: [longTier1, longTier2, longTier3],
                short: [shortTier1, shortTier2, shortTier3]
            };
            const levelDetailsJson = JSON.stringify(levelDetails);

            if (window.lastLevelDetails !== levelDetailsJson) {
                // Clear old Level/Tier lines
                if (window.currentLevelLines) {
                    window.currentLevelLines.forEach(line => candleSeries.removePriceLine(line));
                }
                window.currentLevelLines = [];

                // Add Base Level
                window.currentLevelLines.push(candleSeries.createPriceLine({
                    price: levelPrice,
                    color: '#000000',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Solid,
                    axisLabelVisible: true,
                    title: 'Base Level',
                }));

                // Add Tier Lines
                const addTierLine = (price, label, color) => {
                    window.currentLevelLines.push(candleSeries.createPriceLine({
                        price: price,
                        color: color,
                        lineWidth: 1,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        axisLabelVisible: true,
                        title: label,
                    }));
                };

                addTierLine(longTier1, 'L-T1', '#28a745');
                addTierLine(longTier2, 'L-T2', '#28a745');
                addTierLine(longTier3, 'L-T3', '#28a745');

                addTierLine(shortTier1, 'S-T1', '#dc3545');
                addTierLine(shortTier2, 'S-T2', '#dc3545');
                addTierLine(shortTier3, 'S-T3', '#dc3545');

                window.lastLevelDetails = levelDetailsJson;
            }

            // Fetch and Render Liquidity Clusters
            try {
                const liqResp = await fetch(`/api/liquidity?symbol=${symbol}`);
                const clusters = await liqResp.json();
                const clustersJson = JSON.stringify(clusters);

                if (window.lastLiquidityJson !== clustersJson) {
                    // Clear old Liquidity lines from LIQUIDITY SERIES
                    if (window.currentLiquidityLines) {
                        window.currentLiquidityLines.forEach(line => liquiditySeries.removePriceLine(line));
                    }
                    window.currentLiquidityLines = [];

                    if (clusters && clusters.length > 0) {
                        // Find max volume for scaling
                        const maxVol = Math.max(...clusters.map(c => c.volume));

                        clusters.forEach(c => {
                            // Intensity Clamping: clamp(size/max_size, 0..1)
                            let opacity = 0.0;
                            if (maxVol > 0) {
                                opacity = c.volume / maxVol;
                                if (opacity > 1.0) opacity = 1.0;
                                if (opacity < 0.0) opacity = 0.0;
                            }

                            // Ensure minimum visibility for anything returned by backend
                            if (opacity < 0.1) opacity = 0.1;

                            const color = c.type === 'bid'
                                ? `rgba(0, 255, 0, ${opacity.toFixed(2)})`
                                : `rgba(255, 105, 180, ${opacity.toFixed(2)})`; // Pink for Asks

                            // Add to LIQUIDITY SERIES (Background)
                            window.currentLiquidityLines.push(liquiditySeries.createPriceLine({
                                price: c.price,
                                color: color,
                                lineWidth: 2, // Fixed width
                                lineStyle: LightweightCharts.LineStyle.Solid,
                                axisLabelVisible: false,
                                title: '',
                            }));
                        });
                    }
                    window.lastLiquidityJson = clustersJson;
                }
            } catch (e) {
                console.error("Failed to fetch liquidity", e);
            }
        }

        // Update chart when levels table updates
        document.body.addEventListener('htmx:afterSwap', function (event) {
            if (event.detail.target.id === 'levels-table') {
                updateChart();
            }
        });

        // Initial render
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(updateChart, 500);
        });

        // Retry mechanism for updateChart if selector is missing
        let updateChartRetryCount = 0;


        // Tier Tips Logic
        function updateTierTips() {
            const priceInput = document.getElementById('input-level-price');
            if (!priceInput) return;

            const price = parseFloat(priceInput.value);
            if (isNaN(price)) return;

            ['tier1', 'tier2', 'tier3'].forEach(tier => {
                const input = document.getElementById(`input-${tier}`);
                const tip = document.getElementById(`tip-${tier}`);
                if (!input || !tip) return;

                const pct = parseFloat(input.value);
                if (isNaN(pct)) {
                    tip.innerHTML = '';
                    return;
                }

                const longPrice = price * (1 + pct / 100);
                const shortPrice = price * (1 - pct / 100);

                tip.innerHTML = `<span style="color:#28a745" title="Long (Above)">L:${longPrice.toFixed(6)}</span><br><span style="color:#dc3545" title="Short (Below)">S:${shortPrice.toFixed(6)}</span>`;
            });
        }

        // Add listeners
        const priceInput = document.getElementById('input-level-price');
        if (priceInput) {
            priceInput.addEventListener('input', updateTierTips);
            // Also update on load if value exists
            updateTierTips();
        }
        ['tier1', 'tier2', 'tier3'].forEach(tier => {
            const input = document.getElementById(`input-${tier}`);
            if (input) input.addEventListener('input', updateTierTips);
        });

        // Call once on init
        setTimeout(updateTierTips, 100);

        // Market Stats Logic
        async function updateMarketStats() {
            const selector = document.getElementById('level-selector');
            // Use selected level symbol or default
            let symbol = "BTCUSDT";
            if (selector && selector.value) {
                // value is symbol-price, extract symbol
                const parts = selector.value.split('-');
                if (parts.length > 0) symbol = parts[0];
            }

            try {
                const resp = await fetch(`/api/market-stats?symbol=${symbol}`);
                const stats = await resp.json();

                // Update Speed Gauge
                // Ratio: Buy / (Buy + Sell). 0 = Full Sell (-90deg), 1 = Full Buy (90deg)
                const totalSpeed = stats.speed_buy + stats.speed_sell;
                let speedRatio = 0.5;
                if (totalSpeed > 0) {
                    speedRatio = stats.speed_buy / totalSpeed;
                }
                // Map 0..1 to -90..90
                const speedDeg = (speedRatio * 180) - 90;
                const speedNeedle = document.getElementById('speed-needle');
                if (speedNeedle) speedNeedle.style.transform = `rotate(${speedDeg}deg)`;

                const speedValue = document.getElementById('speed-value');
                if (speedValue) speedValue.textContent = `${stats.speed_sell.toFixed(2)} / ${stats.speed_buy.toFixed(2)}`;


                // Update Depth Gauge
                // Ratio: Bid / (Bid + Ask). 0 = Full Ask (-90deg), 1 = Full Bid (90deg)
                // Wait, usually Left=Ask (Sell pressure), Right=Bid (Buy pressure).
                // If Bid is high, price goes UP (Right). If Ask is high, price goes DOWN (Left).
                // So Bid Ratio -> Right.
                const totalDepth = stats.depth_bid + stats.depth_ask;
                let depthRatio = 0.5;
                if (totalDepth > 0) {
                    depthRatio = stats.depth_bid / totalDepth;
                }
                const depthDeg = (depthRatio * 180) - 90;
                const depthNeedle = document.getElementById('depth-needle');
                if (depthNeedle) depthNeedle.style.transform = `rotate(${depthDeg}deg)`;

                const depthValue = document.getElementById('depth-value');
                if (depthValue) depthValue.textContent = `${stats.depth_ask.toFixed(2)} / ${stats.depth_bid.toFixed(2)}`;

                // Update Divergence Gauge
                // Divergence = TradeSentiment - DepthSentiment
                // TradeSentiment = speedRatio (0..1, 1=Buy)
                // DepthSentiment = depthRatio (0..1, 1=Bid/Buy)
                // Div = speedRatio - depthRatio
                // Range: -1 (Max Sell Speed, Max Buy Depth) to +1 (Max Buy Speed, Max Sell Depth)
                // Wait, if Speed=Buy(1) and Depth=Buy(1), Div=0 (Agreement).
                // If Speed=Buy(1) and Depth=Sell(0), Div=1 (Bullish Divergence? Price moving up despite sell wall?)
                // Let's define:
                // Bullish Div: High Buy Speed vs Low Buy Depth (Sell Wall eating) -> Speed(1) - Depth(0) = 1
                // Bearish Div: High Sell Speed vs Low Sell Depth (Buy Wall eating) -> Speed(0) - Depth(1) = -1

                const divergence = speedRatio - depthRatio;
                // Map -1..1 to -90..90
                const divDeg = divergence * 90;

                const divNeedle = document.getElementById('div-needle');
                if (divNeedle) divNeedle.style.transform = `rotate(${divDeg}deg)`;

                const divValue = document.getElementById('div-value');
                if (divValue) divValue.textContent = divergence.toFixed(2);

            } catch (e) {
                console.error("Failed to fetch market stats", e);
            }
        }

        // Update stats every 1s
        setInterval(updateMarketStats, 1000);
        // Also update when level changes
        const levelSelector = document.getElementById('level-selector');
        if (levelSelector) {
            levelSelector.addEventListener('change', updateMarketStats);
        }
    </script>



    <div class="card">
        <h2>Active Positions</h2>
        <div id="positions-table" hx-get="/positions" hx-trigger="load, every 5s">
            <!-- Loaded via HTMX -->
        </div>
    </div>

    <div class="card">
        <h2>Recent Trades</h2>
        <div hx-get="/trades" hx-trigger="every 5s">
            <!-- Initial load or empty -->
        </div>
    </div>
    </div>
</body>

</html>

{{ define "levels_table" }}
<table>
    <thead>
        <tr>
            <th>Exchange</th>
            <th>Symbol</th>
            <th>Level Price</th>
            <th>Current Price</th>
            <th>Zone/Tiers</th>
            <th>Size</th>
            <th>Lev</th>
            <th>Margin</th>
            <th>Cooldown</th>
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        {{ range . }}
        <tr>
            <td>{{ .Exchange }}</td>
            <td><strong>{{ .Symbol }}</strong></td>
            <td>{{ printf "%.6f" .LevelPrice }}</td>
            <td>{{ printf "%.6f" .CurrentPrice }}</td>
            <td>
                <table style="width: 100%; font-size: 0.9em;">
                    <tr>
                        <td style="font-weight: bold; color: #28a745; padding: 2px;">LONG</td>
                        <td style="background-color: #d4edda; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .LongTiers 0) }}</td>
                        <td style="background-color: #d4edda; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .LongTiers 1) }}</td>
                        <td style="background-color: #d4edda; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .LongTiers 2) }}</td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; color: #dc3545; padding: 2px;">SHORT</td>
                        <td style="background-color: #f8d7da; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .ShortTiers 0) }}</td>
                        <td style="background-color: #f8d7da; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .ShortTiers 1) }}</td>
                        <td style="background-color: #f8d7da; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .ShortTiers 2) }}</td>
                    </tr>
                </table>
            </td>
            <td>{{ .BaseSize }}</td>
            <td>{{ .Leverage }}x</td>
            <td style="font-weight: bold; color: {{ if eq .MarginType " isolated" }}#007bff{{ else }}#6c757d{{ end }};">
                {{ .MarginType }}</td>
            <td>{{ .CoolDownMs }}ms</td>
            <td>{{ if .StopLossAtBase }}<span style="color: red; font-weight: bold;">YES</span>{{ else }}NO{{ end }}
            </td>
            <td>
                <button class="delete-btn" hx-delete="/levels/{{ .ID }}" hx-target="#levels-table">Delete</button>
            </td>
        </tr>
        {{ end }}
    </tbody>
</table>
{{ end }}

{{ define "trades_table" }}
<table>
    <thead>
        <tr>
            <th>Time</th>
            <th>Symbol</th>
            <th>Side</th>
            <th>Size</th>
            <th>Price</th>
        </tr>
    </thead>
    <tbody>
        {{ range . }}
        <tr>
            <td>{{ .CreatedAt.Format "15:04:05" }}</td>
            <td>{{ .Symbol }}</td>
            <td>{{ .Side }}</td>
            <td>{{ .Size }}</td>
            <td>{{ printf "%.6f" .Price }}</td>
        </tr>
        {{ end }}
    </tbody>
</table>
{{ end }}

{{ define "positions_table" }}
<table>
    <thead>
        <tr>
            <th>Symbol</th>
            <th>Side</th>
            <th>Size</th>
            <th>Entry Price</th>
            <th>Mark Price</th>
            <th>Unrealized PnL</th>
            <th>Lev</th>
            <th>Margin</th>
        </tr>
    </thead>
    <tbody>
        {{ if . }}
        {{ range . }}
        <tr>
            <td>{{ .Symbol }}</td>
            <td>{{ .Side }}</td>
            <td>{{ .Size }}</td>
            <td>{{ printf "%.6f" .EntryPrice }}</td>
            <td>{{ printf "%.6f" .CurrentPrice }}</td>
            <td style="color: {{ if gt .UnrealizedPnL 0.0 }}green{{ else }}red{{ end }};">{{ printf "%.6f"
                .UnrealizedPnL }}</td>
            <td>{{ .Leverage }}</td>
            <td style="font-weight: bold; color: {{ if eq .MarginType " isolated" }}#007bff{{ else }}#6c757d{{ end }};">
                {{ .MarginType }}</td>
        </tr>
        {{ end }}
        {{ else }}
        <tr>
            <td colspan="8">No active positions</td>
        </tr>
        {{ end }}
    </tbody>
</table>
{{ end }}