<!-- index.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Level Trader Bot</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: #f0f2f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            text-align: left;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        input,
        select {
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        .delete-btn {
            background: #dc3545;
        }

        .delete-btn:hover {
            background: #a71d2a;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Level Trader Bot</h1>

        <div class="card">
            <h2>Add Level</h2>
            <form hx-post="/levels" hx-target="#levels-table">
                <input type="text" name="exchange" placeholder="Exchange (bybit)" value="bybit" required>
                <input type="text" name="symbol" placeholder="Symbol (BTCUSDT)" required>
                <input type="number" step="0.000001" name="level_price" id="input-level-price" placeholder="Level Price"
                    required>
                <input type="number" step="0.001" name="base_size" placeholder="Base Size" required>
                <input type="number" name="leverage" placeholder="Leverage" value="10" required>
                <select name="margin_type">
                    <option value="isolated">Isolated</option>
                    <option value="cross">Cross</option>
                </select>
                <input type="number" name="cool_down_ms" placeholder="Cooldown (ms)" value="5000" required>
                <div style="margin-top: 10px; display: flex; align-items: flex-start; gap: 10px;">
                    <label style="margin-top: 5px;">Tiers (%):</label>
                    <div>
                        <input type="number" step="0.01" name="tier1" id="input-tier1" placeholder="Tier 1 (0.5)"
                            value="0.5" required style="width: 80px;">
                        <div id="tip-tier1" style="font-size: 0.8em; color: #666; margin-top: 2px;"></div>
                    </div>
                    <div>
                        <input type="number" step="0.01" name="tier2" id="input-tier2" placeholder="Tier 2 (0.3)"
                            value="0.3" required style="width: 80px;">
                        <div id="tip-tier2" style="font-size: 0.8em; color: #666; margin-top: 2px;"></div>
                    </div>
                    <div>
                        <input type="number" step="0.01" name="tier3" id="input-tier3" placeholder="Tier 3 (0.15)"
                            value="0.15" required style="width: 80px;">
                        <div id="tip-tier3" style="font-size: 0.8em; color: #666; margin-top: 2px;"></div>
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <input type="checkbox" id="stop_loss_at_base" name="stop_loss_at_base">
                    <label for="stop_loss_at_base">Stop Loss at Base</label>
                </div>
                <button type="submit" style="margin-top: 10px;">Add Level</button>
            </form>
        </div>

        <div class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0;">Level Visualization</h2>
                <div style="display: flex; align-items: center;">
                    <label for="level-selector" style="margin-right: 10px; font-weight: bold;">Select Level:</label>
                    <select id="level-selector" onchange="changeLevel()"
                        style="padding: 5px; border-radius: 4px; border: 1px solid #ccc;">
                        <option value="">Loading levels...</option>
                    </select>
                </div>
            </div>
            <div style="position: relative; height: 400px;">
                <div id="levelChart" style="width: 100%; height: 100%;"></div>
            </div>
            <div id="chart-legend" style="margin-top: 10px; font-size: 12px; color: #666;">
                <span style="color: #28a745;">█</span> LONG Zone (above level) |
                <span style="color: #dc3545;">█</span> SHORT Zone (below level) |
                <span style="color: #000;">━</span> Base Level |
                <span style="color: #666;">- - -</span> Tiers
            </div>
        </div>

        <div class="card">
            <h2>Active Levels</h2>
            <div id="levels-table" hx-get="/levels" hx-trigger="every 2s">
                {{ template "levels_table" .Levels }}
            </div>
        </div>

        <script>
            let chart = null;
            let candleSeries = null;
            let liquiditySeries = null; // New series for background lines
            let selectedLevelId = null;
            let currentPriceLines = [];

            function initChart() {
                console.log("Initializing Chart...");
                const chartContainer = document.getElementById('levelChart');
                if (!chartContainer) {
                    console.error("Chart container not found!");
                    return;
                }

                // Clear previous content
                chartContainer.innerHTML = '';

                if (typeof LightweightCharts === 'undefined') {
                    console.error("LightweightCharts library not loaded!");
                    return;
                }

                try {
                    chart = LightweightCharts.createChart(chartContainer, {
                        width: chartContainer.clientWidth || 800, // Fallback width
                        height: 400,
                        layout: {
                            background: { type: 'solid', color: 'white' },
                            textColor: 'black',
                        },
                        grid: {
                            vertLines: { color: '#eee' },
                            horzLines: { color: '#eee' },
                        },
                        rightPriceScale: {
                            borderColor: '#d1d4dc',
                        },
                        timeScale: {
                            borderColor: '#d1d4dc',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                    });

                    // 1. Create Liquidity Series FIRST (so it renders behind)
                    // We use a LineSeries but make it invisible
                    liquiditySeries = chart.addLineSeries({
                        color: 'transparent',
                        lineWidth: 0,
                        crosshairMarkerVisible: false,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });

                    // 2. Create Candle Series SECOND (so it renders on top)
                    candleSeries = chart.addCandlestickSeries({
                        upColor: '#26a69a',
                        downColor: '#ef5350',
                        borderVisible: false,
                        wickUpColor: '#26a69a',
                        wickDownColor: '#ef5350',
                        priceFormat: {
                            type: 'price',
                            precision: 6,
                            minMove: 0.000001,
                        },
                    });

                    console.log("Chart initialized. Series:", candleSeries);

                    // Handle resize
                    window.addEventListener('resize', () => {
                        if (chart && chartContainer) {
                            chart.applyOptions({ width: chartContainer.clientWidth });
                        }
                    });
                } catch (e) {
                    console.error("Error initializing chart:", e);
                    chart = null;
                    candleSeries = null;
                    liquiditySeries = null;
                }
            }

            function changeLevel() {
                const selector = document.getElementById('level-selector');
                selectedLevelId = selector.value;
                updateChart();
            }

            async function updateChart() {
                if (!chart) {
                    initChart();
                    if (!chart) {
                        console.warn("Chart init failed, skipping update");
                        return;
                    }
                }

                if (!candleSeries || !liquiditySeries) {
                    console.error("Series is null, re-initializing...");
                    // Try to recover?
                    initChart();
                    if (!candleSeries) return;
                }

                // Get data from the levels table to find selected level details
                const table = document.querySelector('#levels-table table');
                if (!table) return;

                const rows = table.querySelectorAll('tbody tr');
                if (rows.length === 0) return;

                // Populate selector logic (same as before)
                const selector = document.getElementById('level-selector');
                const currentOptions = Array.from(selector.options).map(o => o.value);
                const availableLevels = [];
                const activeIds = [];

                rows.forEach((row) => {
                    const cells = row.querySelectorAll('td');
                    const symbol = cells[1].textContent.trim();
                    const levelPrice = parseFloat(cells[2].textContent);
                    const id = `${symbol}-${levelPrice}`;
                    activeIds.push(id);
                    availableLevels.push({ id, text: `${symbol} @ ${levelPrice}` });

                    if (!currentOptions.includes(id)) {
                        const option = document.createElement('option');
                        option.value = id;
                        option.text = `${symbol} @ ${levelPrice}`;
                        selector.appendChild(option);
                    }
                });

                // Cleanup options
                Array.from(selector.options).forEach(option => {
                    if (option.value && !activeIds.includes(option.value)) {
                        selector.removeChild(option);
                    }
                });

                // Default selection
                if ((!selectedLevelId || !activeIds.includes(selectedLevelId)) && availableLevels.length > 0) {
                    selectedLevelId = availableLevels[0].id;
                    selector.value = selectedLevelId;
                }

                // Find target row
                let targetRow = null;
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    const symbol = cells[1].textContent.trim();
                    const levelPrice = parseFloat(cells[2].textContent);
                    const id = `${symbol}-${levelPrice}`;
                    if (id === selectedLevelId) {
                        targetRow = row;
                    }
                });

                if (!targetRow) return;

                const cells = targetRow.querySelectorAll('td');
                const symbol = cells[1].textContent.trim();
                const levelPrice = parseFloat(cells[2].textContent);

                // Fetch Candles
                try {
                    const response = await fetch(`/api/candles?symbol=${symbol}&interval=15&limit=200`);
                    const candles = await response.json();
                    if (candles && candles.length > 0) {
                        // Ensure candles are sorted by time (ascending)
                        candles.sort((a, b) => a.time - b.time);

                        // Deduplicate candles by time
                        const uniqueCandles = [];
                        const seenTimes = new Set();
                        for (const c of candles) {
                            if (!seenTimes.has(c.time)) {
                                seenTimes.add(c.time);
                                uniqueCandles.push(c);
                            }
                        }

                        candleSeries.setData(uniqueCandles);

                        // Sync liquiditySeries with same data (using close price)
                        // This ensures it shares the same scale and range
                        const lineData = uniqueCandles.map(c => ({ time: c.time, value: c.close }));
                        liquiditySeries.setData(lineData);
                    }
                } catch (e) {
                    console.error("Failed to fetch candles", e);
                }

                // Update Price Lines (Level and Tiers)
                // We will track active lines to avoid clearing/re-adding if not needed.
                // However, LightweightCharts doesn't support updating PriceLine properties easily.
                // But for Liquidity lines, we can diff the data.
                // For Level/Tiers, they change rarely (only if user edits).

                // Strategy:
                // 1. Level/Tiers: Clear and re-add ONLY if level details changed (price/tiers).
                // 2. Liquidity: Fetch, diff with current. If different, clear and re-add ONLY liquidity lines.

                // For simplicity in this MVP, let's separate the arrays.
                // currentLevelLines (Base + Tiers)
                // currentLiquidityLines (Order Book)

                // Parse Tiers from the nested table in cell 4
                const tierCell = cells[4];
                const nestedTable = tierCell.querySelector('table');
                let longTier1, longTier2, longTier3, shortTier1, shortTier2, shortTier3;

                if (nestedTable) {
                    const nestedRows = nestedTable.querySelectorAll('tr');
                    if (nestedRows.length >= 2) {
                        // Long Tiers (Row 0)
                        const longCells = nestedRows[0].querySelectorAll('td');
                        longTier1 = parseFloat(longCells[1].textContent);
                        longTier2 = parseFloat(longCells[2].textContent);
                        longTier3 = parseFloat(longCells[3].textContent);

                        // Short Tiers (Row 1)
                        const shortCells = nestedRows[1].querySelectorAll('td');
                        shortTier1 = parseFloat(shortCells[1].textContent);
                        shortTier2 = parseFloat(shortCells[2].textContent);
                        shortTier3 = parseFloat(shortCells[3].textContent);
                    }
                }

                // Fallback if parsing fails (shouldn't happen if table structure is correct)
                if (!longTier1) {
                    console.warn("Failed to parse tiers from table, using defaults");
                    longTier1 = levelPrice * (1 + 0.005);
                    longTier2 = levelPrice * (1 + 0.003);
                    longTier3 = levelPrice * (1 + 0.0015);
                    shortTier1 = levelPrice * (1 - 0.005);
                    shortTier2 = levelPrice * (1 - 0.003);
                    shortTier3 = levelPrice * (1 - 0.0015);
                }

                // Check if level details changed
                const levelDetails = {
                    price: levelPrice,
                    long: [longTier1, longTier2, longTier3],
                    short: [shortTier1, shortTier2, shortTier3]
                };
                const levelDetailsJson = JSON.stringify(levelDetails);

                if (window.lastLevelDetails !== levelDetailsJson) {
                    // Clear old Level/Tier lines
                    if (window.currentLevelLines) {
                        window.currentLevelLines.forEach(line => candleSeries.removePriceLine(line));
                    }
                    window.currentLevelLines = [];

                    // Add Base Level
                    window.currentLevelLines.push(candleSeries.createPriceLine({
                        price: levelPrice,
                        color: '#000000',
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Solid,
                        axisLabelVisible: true,
                        title: 'Base Level',
                    }));

                    // Add Tier Lines
                    const addTierLine = (price, label, color) => {
                        window.currentLevelLines.push(candleSeries.createPriceLine({
                            price: price,
                            color: color,
                            lineWidth: 1,
                            lineStyle: LightweightCharts.LineStyle.Dashed,
                            axisLabelVisible: true,
                            title: label,
                        }));
                    };

                    addTierLine(longTier1, 'L-T1', '#28a745');
                    addTierLine(longTier2, 'L-T2', '#28a745');
                    addTierLine(longTier3, 'L-T3', '#28a745');

                    addTierLine(shortTier1, 'S-T1', '#dc3545');
                    addTierLine(shortTier2, 'S-T2', '#dc3545');
                    addTierLine(shortTier3, 'S-T3', '#dc3545');

                    window.lastLevelDetails = levelDetailsJson;
                }

                // Fetch and Render Liquidity Clusters
                try {
                    const liqResp = await fetch(`/api/liquidity?symbol=${symbol}`);
                    const clusters = await liqResp.json();
                    const clustersJson = JSON.stringify(clusters);

                    if (window.lastLiquidityJson !== clustersJson) {
                        // Clear old Liquidity lines from LIQUIDITY SERIES
                        if (window.currentLiquidityLines) {
                            window.currentLiquidityLines.forEach(line => liquiditySeries.removePriceLine(line));
                        }
                        window.currentLiquidityLines = [];

                        if (clusters && clusters.length > 0) {
                            // Find max volume for scaling
                            const maxVol = Math.max(...clusters.map(c => c.volume));

                            clusters.forEach(c => {
                                // Intensity Clamping: clamp(size/max_size, 0..1)
                                let opacity = 0.0;
                                if (maxVol > 0) {
                                    opacity = c.volume / maxVol;
                                    if (opacity > 1.0) opacity = 1.0;
                                    if (opacity < 0.0) opacity = 0.0;
                                }

                                // Ensure minimum visibility for anything returned by backend
                                if (opacity < 0.1) opacity = 0.1;

                                const color = c.type === 'bid'
                                    ? `rgba(0, 255, 0, ${opacity.toFixed(2)})`
                                    : `rgba(255, 105, 180, ${opacity.toFixed(2)})`; // Pink for Asks

                                // Add to LIQUIDITY SERIES (Background)
                                window.currentLiquidityLines.push(liquiditySeries.createPriceLine({
                                    price: c.price,
                                    color: color,
                                    lineWidth: 2, // Fixed width
                                    lineStyle: LightweightCharts.LineStyle.Solid,
                                    axisLabelVisible: false,
                                    title: '',
                                }));
                            });
                        }
                        window.lastLiquidityJson = clustersJson;
                    }
                } catch (e) {
                    console.error("Failed to fetch liquidity", e);
                }
            }

            // Update chart when levels table updates
            document.body.addEventListener('htmx:afterSwap', function (event) {
                if (event.detail.target.id === 'levels-table') {
                    updateChart();
                }
            });

            // Initial render
            setTimeout(updateChart, 500);

            // Tier Tips Logic
            function updateTierTips() {
                const priceInput = document.getElementById('input-level-price');
                if (!priceInput) return;

                const price = parseFloat(priceInput.value);
                if (isNaN(price)) return;

                ['tier1', 'tier2', 'tier3'].forEach(tier => {
                    const input = document.getElementById(`input-${tier}`);
                    const tip = document.getElementById(`tip-${tier}`);
                    if (!input || !tip) return;

                    const pct = parseFloat(input.value);
                    if (isNaN(pct)) {
                        tip.innerHTML = '';
                        return;
                    }

                    const longPrice = price * (1 + pct / 100);
                    const shortPrice = price * (1 - pct / 100);

                    tip.innerHTML = `<span style="color:#28a745" title="Long (Above)">L:${longPrice.toFixed(6)}</span><br><span style="color:#dc3545" title="Short (Below)">S:${shortPrice.toFixed(6)}</span>`;
                });
            }

            // Add listeners
            const priceInput = document.getElementById('input-level-price');
            if (priceInput) {
                priceInput.addEventListener('input', updateTierTips);
                // Also update on load if value exists
                updateTierTips();
            }
            ['tier1', 'tier2', 'tier3'].forEach(tier => {
                const input = document.getElementById(`input-${tier}`);
                if (input) input.addEventListener('input', updateTierTips);
            });

            // Call once on init
            setTimeout(updateTierTips, 100);
        </script>



        <div class="card">
            <h2>Active Positions</h2>
            <div id="positions-table" hx-get="/positions" hx-trigger="load, every 5s">
                <!-- Loaded via HTMX -->
            </div>
        </div>

        <div class="card">
            <h2>Recent Trades</h2>
            <div hx-get="/trades" hx-trigger="every 5s">
                <!-- Initial load or empty -->
            </div>
        </div>
    </div>
</body>

</html>

{{ define "levels_table" }}
<table>
    <thead>
        <tr>
            <th>Exchange</th>
            <th>Symbol</th>
            <th>Level Price</th>
            <th>Current Price</th>
            <th>Zone/Tiers</th>
            <th>Size</th>
            <th>Lev</th>
            <th>Margin</th>
            <th>Cooldown</th>
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        {{ range . }}
        <tr>
            <td>{{ .Exchange }}</td>
            <td><strong>{{ .Symbol }}</strong></td>
            <td>{{ printf "%.6f" .LevelPrice }}</td>
            <td>{{ printf "%.6f" .CurrentPrice }}</td>
            <td>
                <table style="width: 100%; font-size: 0.9em;">
                    <tr>
                        <td style="font-weight: bold; color: #28a745; padding: 2px;">LONG</td>
                        <td style="background-color: #d4edda; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .LongTiers 0) }}</td>
                        <td style="background-color: #d4edda; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .LongTiers 1) }}</td>
                        <td style="background-color: #d4edda; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .LongTiers 2) }}</td>
                    </tr>
                    <tr>
                        <td style="font-weight: bold; color: #dc3545; padding: 2px;">SHORT</td>
                        <td style="background-color: #f8d7da; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .ShortTiers 0) }}</td>
                        <td style="background-color: #f8d7da; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .ShortTiers 1) }}</td>
                        <td style="background-color: #f8d7da; font-weight: bold; padding: 2px;">{{ printf "%.6f" (index
                            .ShortTiers 2) }}</td>
                    </tr>
                </table>
            </td>
            <td>{{ .BaseSize }}</td>
            <td>{{ .Leverage }}x</td>
            <td style="font-weight: bold; color: {{ if eq .MarginType " isolated" }}#007bff{{ else }}#6c757d{{ end }};">
                {{ .MarginType }}</td>
            <td>{{ .CoolDownMs }}ms</td>
            <td>{{ if .StopLossAtBase }}<span style="color: red; font-weight: bold;">YES</span>{{ else }}NO{{ end }}
            </td>
            <td>
                <button class="delete-btn" hx-delete="/levels/{{ .ID }}" hx-target="#levels-table">Delete</button>
            </td>
        </tr>
        {{ end }}
    </tbody>
</table>
{{ end }}

{{ define "trades_table" }}
<table>
    <thead>
        <tr>
            <th>Time</th>
            <th>Symbol</th>
            <th>Side</th>
            <th>Size</th>
            <th>Price</th>
        </tr>
    </thead>
    <tbody>
        {{ range . }}
        <tr>
            <td>{{ .CreatedAt.Format "15:04:05" }}</td>
            <td>{{ .Symbol }}</td>
            <td>{{ .Side }}</td>
            <td>{{ .Size }}</td>
            <td>{{ printf "%.6f" .Price }}</td>
        </tr>
        {{ end }}
    </tbody>
</table>
{{ end }}

{{ define "positions_table" }}
<table>
    <thead>
        <tr>
            <th>Symbol</th>
            <th>Side</th>
            <th>Size</th>
            <th>Entry Price</th>
            <th>Mark Price</th>
            <th>Unrealized PnL</th>
            <th>Lev</th>
            <th>Margin</th>
        </tr>
    </thead>
    <tbody>
        {{ if . }}
        {{ range . }}
        <tr>
            <td>{{ .Symbol }}</td>
            <td>{{ .Side }}</td>
            <td>{{ .Size }}</td>
            <td>{{ printf "%.6f" .EntryPrice }}</td>
            <td>{{ printf "%.6f" .CurrentPrice }}</td>
            <td style="color: {{ if gt .UnrealizedPnL 0.0 }}green{{ else }}red{{ end }};">{{ printf "%.6f"
                .UnrealizedPnL }}</td>
            <td>{{ .Leverage }}</td>
            <td style="font-weight: bold; color: {{ if eq .MarginType " isolated" }}#007bff{{ else }}#6c757d{{ end }};">
                {{ .MarginType }}</td>
        </tr>
        {{ end }}
        {{ else }}
        <tr>
            <td colspan="8">No active positions</td>
        </tr>
        {{ end }}
    </tbody>
</table>
{{ end }}